<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¹´ë©”ë¼ í…ŒìŠ¤íŠ¸ (24fps ìº¡ì²˜)</title>
    <style>
        .app {
            text-align: center;
            padding: 20px;
        }
        h1 {
            margin-bottom: 20px;
        }
        .error {
            color: red;
            margin-bottom: 10px;
        }
        .status {
            color: #333;
            margin: 10px 0;
            font-family: monospace;
        }
        video {
            width: 100%;
            max-width: 640px;
            display: block;
            margin: 0 auto 20px;
            border: 1px solid #ccc;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 0 5px;
        }
        button:hover {
            background-color: #cc0000;
        }
        canvas {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app">
        <h1>ì¹´ë©”ë¼ í…ŒìŠ¤íŠ¸</h1>
        <p id="error" class="error"></p>
        <div id="status" class="status">ëŒ€ê¸° ì¤‘...</div>
        <video id="video" autoplay playsinline></video>
        <div>
            <button id="stopBtn">ì¹´ë©”ë¼ ë„ê¸°</button>
        </div>
        <audio id="audioPlayer" src="./ë‹¹ëŒí•œì—¬ì.mp3" controls></audio>
        <canvas id="captureCanvas" width="320" height="240"></canvas>
    </div>

    <script>
        const video = document.getElementById('video');
        const errorElement = document.getElementById('error');
        const statusElement = document.getElementById('status');
        const stopBtn = document.getElementById('stopBtn');
        const canvas = document.getElementById('captureCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audioPlayer');

        // ===== ì„¤ì • =====
        const MAX_RETRIES = 3;
        const FPS = 24;
        const FRAME_MS = 1000 / FPS;
        const EPS = 0.03;
        const LATE_GUARD = 0.02;

        // ===== ìƒíƒœ ë³€ìˆ˜ =====
        let stream = null;
        let captureIntervalId = null;
        let frameBuffer = [];
        let isCapturing = false;
        let encoding = false;
        let expectedFrames = 0;
        let captureStartTime = 0; // âœ… ì •í™•í•œ íƒ€ì´ë°ì„ ìœ„í•œ ì‹œì‘ ì‹œê°„
        
        // ===== JSON ë°ì´í„° =====
        let barTimes = {};
        let maxBar = 0;
        let barGroups = [];
        let currentGroupIndex = 0;
        let monitoring = false;

        // ===== ì—…ë¡œë“œ í =====
        const uploadQueue = [];
        let isUploading = false;
        const retryMap = new Map();

        // ===== JSON ë¡œë“œ =====
        async function loadBarTimes() {
            try {
                const res = await fetch('./ë‹¹ëŒí•œì—¬ì_ì„¹ì…˜ì¶”ê°€.json');
                const jsonData = await res.json();

                const beats = jsonData.beats;
                const sections = jsonData.sections || [];

                if (!beats || beats.length === 0) {
                    console.error("beats ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                    return;
                }

                beats.forEach(b => {
                    if (b.beat === 1) {
                        barTimes[b.bar] = b.t;
                        if (b.bar > maxBar) maxBar = b.bar;
                    }
                });

                const part1 = sections.find(s => s.label === 'part1');
                const verseStartBar = part1 ? part1.startBar + 4 : 1;

                const BARS_PER_SEGMENT = 4;
                const SEGMENT_COUNT = 6;
                const groups = [];

                for (let i = 0; i < SEGMENT_COUNT; i++) {
                    const startBar = verseStartBar + i * BARS_PER_SEGMENT;
                    const endBar = startBar + BARS_PER_SEGMENT - 1;
                    const startTime = barTimes[startBar];
                    const endTime = barTimes[endBar + 1] || beats[beats.length - 1].t;

                    groups.push({
                        segmentIndex: i + 1,
                        startBar,
                        endBar,
                        startTime,
                        endTime,
                    });
                }

                barGroups = groups;
                console.log("1ì ˆ 4ë§ˆë””ì”©(16ë¹„íŠ¸) 6ì„¸ê·¸ë¨¼íŠ¸:", barGroups);
            } catch (err) {
                console.error("JSON íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨:", err);
            }
        }

        loadBarTimes();

        // ===== ì¹´ë©”ë¼ ì‹œì‘ =====
        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: {
                        width: { ideal: 320 },
                        height: { ideal: 240 },
                        frameRate: { ideal: FPS, max: FPS }
                    },
                    audio: false
                });
                
                video.srcObject = stream;

                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth || 320;
                    canvas.height = video.videoHeight || 240;
                });
            } catch (err) {
                errorElement.textContent = 'ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: ' + err.message;
            }
        }

        // ===== ì¹´ë©”ë¼ ì¤‘ì§€ =====
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            video.srcObject = null;
            stopCapture();
        }

        // ===== í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ ì •ë³´ =====
        function getCurrentGroup() {
            const g = barGroups[currentGroupIndex];
            return { start: g.startTime, end: g.endTime, seg: currentGroupIndex + 1 };
        }

        // ===== ìº¡ì²˜ ì‹œì‘ (ê°œì„ ë¨) =====
        function startCapture() {
            if (isCapturing || captureIntervalId) return;
            if (!video.srcObject) {
                errorElement.textContent = 'ì¹´ë©”ë¼ê°€ ì¼œì ¸ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.';
                return;
            }

            const g = getCurrentGroup();
            const now = audio.currentTime;

            if (now > g.end - LATE_GUARD) {
                console.warn(`â­ skip start seg=${g.seg} (late t=${now.toFixed(2)} > end=${g.end.toFixed(2)})`);
                return;
            }

            isCapturing = true;
            frameBuffer = [];
            expectedFrames = Math.ceil((g.end - Math.max(now, g.start)) * FPS) + 2;
            captureStartTime = performance.now(); // âœ… ê³ ì •ë°€ íƒ€ì´ë¨¸ ì‹œì‘
            let frameCount = 0;

            statusElement.textContent = `ğŸ“¹ ì„¸ê·¸ë¨¼íŠ¸ ${g.seg} ìº¡ì²˜ ì¤‘... (0/${expectedFrames})`;

            // âœ… requestAnimationFrame ê¸°ë°˜ ìº¡ì²˜ (ë” ì •í™•í•¨)
            const captureFrame = () => {
                if (!isCapturing) return;

                const elapsed = performance.now() - captureStartTime;
                const targetFrame = Math.floor(elapsed / FRAME_MS);

                // ë‹¤ìŒ í”„ë ˆì„ ì‹œê°„ê¹Œì§€ ëŒ€ê¸°
                if (frameCount < targetFrame && !encoding && video.readyState >= 2) {
                    encoding = true;
                    frameCount++;

                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                    canvas.toBlob((blob) => {
                        if (!isCapturing) {
                            encoding = false;
                            return;
                        }

                        frameBuffer.push({ 
                            img: blob, 
                            musicTime: audio.currentTime,
                            captureTime: elapsed // âœ… ë””ë²„ê¹…ìš©
                        });

                        statusElement.textContent = `ğŸ“¹ ì„¸ê·¸ë¨¼íŠ¸ ${g.seg} ìº¡ì²˜ ì¤‘... (${frameBuffer.length}/${expectedFrames})`;

                        // ì•ˆì „ ì»·
                        if (frameBuffer.length >= expectedFrames) {
                            stopCapture();
                        }

                        encoding = false;
                    }, 'image/jpeg', 0.8);
                }

                if (isCapturing) {
                    requestAnimationFrame(captureFrame);
                }
            };

            captureFrame();
            console.log(`ğŸ“¹ ìº¡ì²˜ ì‹œì‘ (segment ${g.seg})`);
        }

        // ===== ìº¡ì²˜ ì¤‘ì§€ (ê°œì„ ë¨) =====
        function stopCapture() {
            if (!isCapturing) return;

            isCapturing = false;
            const segIndex = currentGroupIndex;
            const framesToSend = frameBuffer.slice();
            frameBuffer = [];

            console.log(`â¹ ìº¡ì²˜ ì¢…ë£Œ (segment ${segIndex + 1}, ${framesToSend.length} frames)`);
            statusElement.textContent = `â¸ ëŒ€ê¸° ì¤‘...`;

            setTimeout(() => {
                if (framesToSend.length === 0) {
                    console.warn(`ğŸš« seg=${segIndex + 1} has 0 frames â†’ upload skipped`);
                    return;
                }
                queueSegmentUpload(segIndex, framesToSend);
            }, 0);
        }

        // ===== ì—…ë¡œë“œ í =====
        function queueSegmentUpload(index, frames) {
            uploadQueue.push({ index, frames });
            console.log(`ğŸ“¦ ì„¸ê·¸ë¨¼íŠ¸ ${index + 1} ì¤€ë¹„ ì™„ë£Œ (${frames.length} frames)`);
            processUploadQueue();
        }

        // ===== ì—…ë¡œë“œ ì²˜ë¦¬ (ê°œì„ ë¨) =====
        async function processUploadQueue() {
            if (isUploading || uploadQueue.length === 0) return;
            isUploading = true;

            const segment = uploadQueue.shift();
            const segNum = segment.index + 1;
            statusElement.textContent = `ğŸ“¤ ì„¸ê·¸ë¨¼íŠ¸ ${segNum} ì—…ë¡œë“œ ì¤‘... (${segment.frames.length} frames)`;
            console.log(`ğŸ“¤ ì„¸ê·¸ë¨¼íŠ¸ ${segNum} ì—…ë¡œë“œ ì‹œì‘...`);

            try {
                const formData = new FormData();
                
                // âœ… ë©”íƒ€ë°ì´í„° ë¨¼ì € ì¶”ê°€
                formData.append("segmentIndex", segNum);
                formData.append("musicTitle", "ë‹¹ëŒí•œ ì—¬ì");
                formData.append("fps", FPS);
                formData.append("frameCount", segment.frames.length);
                formData.append("musicTimeStart", segment.frames[0]?.musicTime.toFixed(3) || 0);
                formData.append("musicTimeEnd", segment.frames.at(-1)?.musicTime.toFixed(3) || 0);

                // âœ… í”„ë ˆì„ì„ ìˆœì„œëŒ€ë¡œ ì¶”ê°€ (íŒŒì¼ëª…ì— segmentIndex í¬í•¨)
                segment.frames.forEach((frame, i) => {
                    const blob = frame.img instanceof Blob ? frame.img : dataURItoBlob(frame.img);
                    formData.append("frames", blob, `seg${String(segNum).padStart(2, '0')}_frame_${i}.jpg`);
                });

                const response = await fetch("/upload", {
                    method: "POST",
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error(`ì„œë²„ ì‘ë‹µ ì‹¤íŒ¨: ${response.status}`);
                }

                const result = await response.json();
                console.log(`âœ… ì„¸ê·¸ë¨¼íŠ¸ ${segNum} ì—…ë¡œë“œ ì™„ë£Œ`, result);
                statusElement.textContent = `âœ… ì„¸ê·¸ë¨¼íŠ¸ ${segNum} ì—…ë¡œë“œ ì™„ë£Œ`;
                
                // âœ… ì¬ì‹œë„ ì¹´ìš´í„° ì´ˆê¸°í™”
                retryMap.delete(segment.index);

            } catch (err) {
                console.error("ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", err);
                
                const count = retryMap.get(segment.index) || 0;
                if (count < MAX_RETRIES) {
                    retryMap.set(segment.index, count + 1);
                    console.warn(`âš ï¸  ì„¸ê·¸ë¨¼íŠ¸ ${segNum} ì¬ì‹œë„ (${count + 1}/${MAX_RETRIES})`);
                    uploadQueue.push(segment);
                } else {
                    console.error(`ğŸš« ì„¸ê·¸ë¨¼íŠ¸ ${segNum} ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼, ê±´ë„ˆëœ€`);
                    statusElement.textContent = `âŒ ì„¸ê·¸ë¨¼íŠ¸ ${segNum} ì—…ë¡œë“œ ì‹¤íŒ¨`;
                }
            } finally {
                isUploading = false;
                if (uploadQueue.length > 0) {
                    setTimeout(processUploadQueue, 100); // âœ… ì•½ê°„ì˜ ë”œë ˆì´
                }
            }
        }

        // ===== ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ =====
        function dataURItoBlob(dataURI) {
            const byteString = atob(dataURI.split(",")[1]);
            const mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
            return new Blob([ab], { type: mimeString });
        }

        // ===== ëª¨ë‹ˆí„°ë§ ì‹œì‘ =====
        function startMonitoring() {
            if (!barGroups || barGroups.length === 0) {
                console.warn("barGroupsê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.");
                return;
            }

            monitoring = true;
            currentGroupIndex = 0;

            const check = () => {
                if (!monitoring) return;
                const t = audio.currentTime;
                const group = barGroups[currentGroupIndex];

                if (!group) {
                    console.log("ğŸ‰ ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ ì™„ë£Œ");
                    monitoring = false;
                    stopCapture();
                    statusElement.textContent = "ğŸ‰ ë…¹í™” ì™„ë£Œ!";
                    return;
                }

                if (!isCapturing && t >= group.startTime - EPS && t < group.endTime - EPS) {
                    startCapture();
                }
                
                if (isCapturing && t >= group.endTime - EPS) {
                    stopCapture();
                    currentGroupIndex++;
                }

                requestAnimationFrame(check);
            };

            requestAnimationFrame(check);
        }

        // ===== ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ =====
        audio.addEventListener('play', () => {
            console.log('ğŸµ ìŒì•… ì¬ìƒ ì‹œì‘');
            startMonitoring();
        });

        audio.addEventListener('pause', () => {
            console.log('â¸ ìŒì•… ì¼ì‹œì •ì§€');
            stopCapture();
        });

        stopBtn.addEventListener('click', stopCamera);
        window.addEventListener('beforeunload', stopCamera);

        // ===== ì´ˆê¸°í™” =====
        startCamera();
    </script>
</body>
</html>